/// autogenerated analytical inverse kinematics code from ikfast program
/// \author Rosen Diankov
///
/// To compile with gcc use: gcc -lstdc++ 
/// To compile without any main function use: gcc -lstdc++ -DIKFAST_NO_MAIN
#include <math.h>
#include <assert.h>
#include <vector>
#include <float.h>

#define IK2PI  6.28318530717959
#define IKPI  3.14159265358979
#define IKPI_2  1.57079632679490

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

typedef double IKReal;
class IKSolution
{
public:
    /// Gets a solution given its free parameters
    /// \param pfree The free parameters required, range is in [-pi,pi]
    void GetSolution(IKReal* psolution, const IKReal* pfree) const {
        for(size_t i = 0; i < basesol.size(); ++i) {
            if( basesol[i].freeind < 0 )
                psolution[i] = basesol[i].foffset;
            else {
                assert(pfree != NULL);
                psolution[i] = pfree[basesol[i].freeind]*basesol[i].fmul + basesol[i].foffset;
                if( psolution[i] > IKPI )
                    psolution[i] -= IK2PI;
                else if( psolution[i] < -IKPI )
                    psolution[i] += IK2PI;
            }
        }
    }

    /// Gets the free parameters the solution requires to be set before a full solution can be returned
    /// \return vector of indices indicating the free parameters
    const std::vector<int>& GetFree() const { return vfree; }

    struct VARIABLE
    {
        VARIABLE() : freeind(-1), fmul(0), foffset(0) {}
        VARIABLE(int freeind, IKReal fmul, IKReal foffset) : freeind(freeind), fmul(fmul), foffset(foffset) {}
        int freeind;
        IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
    };

    std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
    std::vector<int> vfree;
};

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKasin(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asinf(f);
}
inline double IKasin(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

inline float IKacos(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0f;
return acosf(f);
}
inline double IKacos(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2(fy,fx);
}

IKFAST_API int getNumFreeParameters() { return 1; }
IKFAST_API int* getFreeParameters() { static int freeparams[] = {3}; return freeparams; }
IKFAST_API int getNumJoints() { return 4; }

IKFAST_API int getIKRealSize() { return sizeof(IKReal); }

IKFAST_API int getIKType() { return 3; }

/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    vsolutions.resize(0); vsolutions.reserve(8);
    IKReal j0, cj0, sj0,
    j1, cj1, sj1,
    j2, cj2, sj2,
    j3=pfree[0], cj3=cos(pfree[0]), sj3=sin(pfree[0]),
    _px, _py, _pz, px = eetrans[0], py = eetrans[1], pz = eetrans[2];
    
    _px=((0.00750000000000000)+(px));
    _py=py;
    _pz=((-0.0300000000000000)+(pz));
    px = _px; py = _py; pz = _pz;
    {
    IKReal evalcond;
        evalcond=j3;
        if( IKabs(evalcond) < 0.00001 ) {
        {
        IKReal j0array[2], cj0array[2], sj0array[2];
        bool j0valid[2]={false};
        IKReal x0=((-1.00000000000000)*(py));
        IKReal x1=((-1.00000000000000)*(px));
        IKReal x2=IKatan2(x0, x1);
        j0array[0]=((-1.00000000000000)*(x2));
        sj0array[0]=IKsin(j0array[0]);
        cj0array[0]=IKcos(j0array[0]);
        j0array[1]=((3.14159265358979)+(((-1.00000000000000)*(x2))));
        sj0array[1]=IKsin(j0array[1]);
        cj0array[1]=IKcos(j0array[1]);
        if( j0array[0] > IKPI )
            j0array[0]-=IK2PI;
        else if( j0array[0] < -IKPI )
            j0array[0]+=IK2PI;
        j0valid[0] = true;
        if( j0array[1] > IKPI )
            j0array[1]-=IK2PI;
        else if( j0array[1] < -IKPI )
            j0array[1]+=IK2PI;
        j0valid[1] = true;
        if( j0valid[0] && j0valid[1] && IKabs(cj0array[0]-cj0array[1]) < 0.0001 && IKabs(sj0array[0]-sj0array[1]) < 0.0001 )
            j0valid[1]=false;
        for(int ij0 = 0; ij0 < 2; ++ij0) {
        if( !j0valid[ij0] )
            continue;
        j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
        
        {
        IKReal j2array[2], cj2array[2], sj2array[2];
        bool j2valid[2]={false};
        IKReal x3=((2.95366029808065)*(pz));
        IKReal x4=((5.95069079799578)*(cj0)*(px));
        IKReal x5=((1.13951554775122)+(x3)+(x4));
        IKReal x6=((5.95069079799578)*(py)*(sj0));
        IKReal x7=(px)*(px);
        IKReal x8=((37.3881050390191)*(x7));
        IKReal x9=(py)*(py);
        IKReal x10=((37.3881050390191)*(x9));
        IKReal x11=(pz)*(pz);
        IKReal x12=((37.3881050390191)*(x11));
        IKReal x13=((x6)+(x8)+(x10)+(x12));
        IKReal x14=((((-1.00000000000000)*(x13)))+(x5));
        if( (x14) < -1.0001 || (x14) > 1.0001 )
            continue;
        IKReal x15=IKasin(x14);
        j2array[0]=((-1.88825506204718)+(((-1.00000000000000)*(x15))));
        sj2array[0]=IKsin(j2array[0]);
        cj2array[0]=IKcos(j2array[0]);
        j2array[1]=((1.25333759154261)+(x15));
        sj2array[1]=IKsin(j2array[1]);
        cj2array[1]=IKcos(j2array[1]);
        if( j2array[0] > IKPI )
            j2array[0]-=IK2PI;
        else if( j2array[0] < -IKPI )
            j2array[0]+=IK2PI;
        j2valid[0] = true;
        if( j2array[1] > IKPI )
            j2array[1]-=IK2PI;
        else if( j2array[1] < -IKPI )
            j2array[1]+=IK2PI;
        j2valid[1] = true;
        if( j2valid[0] && j2valid[1] && IKabs(cj2array[0]-cj2array[1]) < 0.0001 && IKabs(sj2array[0]-sj2array[1]) < 0.0001 )
            j2valid[1]=false;
        for(int ij2 = 0; ij2 < 2; ++ij2) {
        if( !j2valid[ij2] )
            continue;
        j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
        
        {
        IKReal j1array[1], cj1array[1], sj1array[1];
        bool j1valid[1]={false};
        IKReal x16=((0.159159999999247)*(py)*(sj0));
        IKReal x17=x9;
        IKReal x18=(sj0)*(sj0);
        IKReal x19=((x17)*(x18));
        IKReal x20=x11;
        IKReal x21=(cj0)*(cj0);
        IKReal x22=x7;
        IKReal x23=((x21)*(x22));
        IKReal x24=((0.00789322639991497)+(x16)+(x19)+(x20)+(x23));
        IKReal x25=((12.5659713495988)*(cj0)*(px)*(x16));
        IKReal x26=((0.0789999999997235)*(pz));
        IKReal x27=((0.159159999999247)*(cj0)*(px));
        IKReal x28=((x25)+(x26)+(x27));
        IKReal x29=((((-1.00000000000000)*(x28)))+(x24));
        IKReal x30=((IKabs(x29) != 0)?((IKReal)1/(x29)):(IKReal)1.0e30);
        j1array[0]=IKatan2(((((0.00647909999992180)*(sj2)*(x30)))+(((-0.000934659999998644)*(cj2)*(x30)))+(((0.886075949361839)*(cj2)*(x26)*(x30)))+(((-0.439808997234650)*(sj2)*(x27)*(x30)))+(((-0.291139240503981)*(sj2)*(x26)*(x30)))+(((0.144508670520736)*(cj2)*(x16)*(x30)))+(((0.439808997234650)*(sj2)*(x16)*(x30)))+(((2.29746835443075)*(x26)*(x30)))+(((-0.144508670520736)*(cj2)*(x27)*(x30)))+(((-0.00716925000000401)*(x30)))), ((((1.14036189997569)*(x27)*(x30)))+(((-0.00647909999992180)*(cj2)*(x30)))+(((-0.0144437699999571)*(x30)))+(((-0.439808997234650)*(cj2)*(x16)*(x30)))+(((-0.144508670520736)*(sj2)*(x27)*(x30)))+(((0.439808997234650)*(cj2)*(x27)*(x30)))+(((-1.14036189997569)*(x16)*(x30)))+(((-0.000934659999998644)*(sj2)*(x30)))+(((0.144508670520736)*(sj2)*(x16)*(x30)))+(((0.291139240503981)*(cj2)*(x26)*(x30)))+(((0.886075949361839)*(sj2)*(x26)*(x30)))));
        sj1array[0]=IKsin(j1array[0]);
        cj1array[0]=IKcos(j1array[0]);
        if( j1array[0] > IKPI )
            j1array[0]-=IK2PI;
        else if( j1array[0] < -IKPI )
            j1array[0]+=IK2PI;
        j1valid[0] = true;
        { int ij1 = 0;
        if( !j1valid[ij1] )
            continue;
        j1 = j1array[0]; cj1 = cj1array[0]; sj1 = sj1array[0];
        
        vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
        solution.basesol.resize(4);
        solution.basesol[0].foffset = j0;
        solution.basesol[1].foffset = j1;
        solution.basesol[2].foffset = j2;
        solution.basesol[3].foffset = j3;
        solution.vfree.resize(0);
        }
        }
        }
        }
        }
        }
        } else {
        evalcond=((((-0.500000000000000)*(3.14159265358979)))+(j3));
        if( IKabs(evalcond) < 0.00001 ) {
        {
        IKReal j0array[2], cj0array[2], sj0array[2];
        bool j0valid[2]={false};
        IKReal x31=((-1.00000000000000)*(py));
        IKReal x32=((-1.00000000000000)*(px));
        IKReal x33=IKatan2(x31, x32);
        j0array[0]=((-1.00000000000000)*(x33));
        sj0array[0]=IKsin(j0array[0]);
        cj0array[0]=IKcos(j0array[0]);
        j0array[1]=((3.14159265358979)+(((-1.00000000000000)*(x33))));
        sj0array[1]=IKsin(j0array[1]);
        cj0array[1]=IKcos(j0array[1]);
        if( j0array[0] > IKPI )
            j0array[0]-=IK2PI;
        else if( j0array[0] < -IKPI )
            j0array[0]+=IK2PI;
        j0valid[0] = true;
        if( j0array[1] > IKPI )
            j0array[1]-=IK2PI;
        else if( j0array[1] < -IKPI )
            j0array[1]+=IK2PI;
        j0valid[1] = true;
        if( j0valid[0] && j0valid[1] && IKabs(cj0array[0]-cj0array[1]) < 0.0001 && IKabs(sj0array[0]-sj0array[1]) < 0.0001 )
            j0valid[1]=false;
        for(int ij0 = 0; ij0 < 2; ++ij0) {
        if( !j0valid[ij0] )
            continue;
        j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
        
        {
        IKReal j2array[2], cj2array[2], sj2array[2];
        bool j2valid[2]={false};
        IKReal x34=((2.95366029808065)*(pz));
        IKReal x35=((5.95069079799578)*(cj0)*(px));
        IKReal x36=((1.13951554775122)+(x35)+(x34));
        IKReal x37=((5.95069079799578)*(py)*(sj0));
        IKReal x38=(px)*(px);
        IKReal x39=((37.3881050390191)*(x38));
        IKReal x40=(py)*(py);
        IKReal x41=((37.3881050390191)*(x40));
        IKReal x42=(pz)*(pz);
        IKReal x43=((37.3881050390191)*(x42));
        IKReal x44=((x39)+(x37)+(x43)+(x41));
        IKReal x45=((((-1.00000000000000)*(x44)))+(x36));
        if( (x45) < -1.0001 || (x45) > 1.0001 )
            continue;
        IKReal x46=IKasin(x45);
        j2array[0]=((-1.88825506204718)+(((-1.00000000000000)*(x46))));
        sj2array[0]=IKsin(j2array[0]);
        cj2array[0]=IKcos(j2array[0]);
        j2array[1]=((1.25333759154261)+(x46));
        sj2array[1]=IKsin(j2array[1]);
        cj2array[1]=IKcos(j2array[1]);
        if( j2array[0] > IKPI )
            j2array[0]-=IK2PI;
        else if( j2array[0] < -IKPI )
            j2array[0]+=IK2PI;
        j2valid[0] = true;
        if( j2array[1] > IKPI )
            j2array[1]-=IK2PI;
        else if( j2array[1] < -IKPI )
            j2array[1]+=IK2PI;
        j2valid[1] = true;
        if( j2valid[0] && j2valid[1] && IKabs(cj2array[0]-cj2array[1]) < 0.0001 && IKabs(sj2array[0]-sj2array[1]) < 0.0001 )
            j2valid[1]=false;
        for(int ij2 = 0; ij2 < 2; ++ij2) {
        if( !j2valid[ij2] )
            continue;
        j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
        
        {
        IKReal j1array[1], cj1array[1], sj1array[1];
        bool j1valid[1]={false};
        IKReal x47=((0.159159999999247)*(py)*(sj0));
        IKReal x48=x40;
        IKReal x49=(sj0)*(sj0);
        IKReal x50=((x48)*(x49));
        IKReal x51=x42;
        IKReal x52=(cj0)*(cj0);
        IKReal x53=x38;
        IKReal x54=((x52)*(x53));
        IKReal x55=((0.00789322639991497)+(x47)+(x54)+(x51)+(x50));
        IKReal x56=((12.5659713495988)*(cj0)*(px)*(x47));
        IKReal x57=((0.0789999999997235)*(pz));
        IKReal x58=((0.159159999999247)*(cj0)*(px));
        IKReal x59=((x58)+(x57)+(x56));
        IKReal x60=((x55)+(((-1.00000000000000)*(x59))));
        IKReal x61=((IKabs(x60) != 0)?((IKReal)1/(x60)):(IKReal)1.0e30);
        j1array[0]=IKatan2(((((0.886075949361839)*(cj2)*(x57)*(x61)))+(((2.29746835443075)*(x57)*(x61)))+(((-0.291139240503981)*(sj2)*(x57)*(x61)))+(((0.00647909999992180)*(sj2)*(x61)))+(((-0.00716925000000401)*(x61)))+(((-0.000934659999998644)*(cj2)*(x61)))+(((0.439808997234650)*(sj2)*(x47)*(x61)))+(((0.144508670520736)*(cj2)*(x47)*(x61)))+(((-0.144508670520736)*(cj2)*(x58)*(x61)))+(((-0.439808997234650)*(sj2)*(x58)*(x61)))), ((((0.291139240503981)*(cj2)*(x57)*(x61)))+(((-0.439808997234650)*(cj2)*(x47)*(x61)))+(((-0.00647909999992180)*(cj2)*(x61)))+(((-1.14036189997569)*(x47)*(x61)))+(((-0.0144437699999571)*(x61)))+(((0.439808997234650)*(cj2)*(x58)*(x61)))+(((0.144508670520736)*(sj2)*(x47)*(x61)))+(((0.886075949361839)*(sj2)*(x57)*(x61)))+(((-0.144508670520736)*(sj2)*(x58)*(x61)))+(((1.14036189997569)*(x58)*(x61)))+(((-0.000934659999998644)*(sj2)*(x61)))));
        sj1array[0]=IKsin(j1array[0]);
        cj1array[0]=IKcos(j1array[0]);
        if( j1array[0] > IKPI )
            j1array[0]-=IK2PI;
        else if( j1array[0] < -IKPI )
            j1array[0]+=IK2PI;
        j1valid[0] = true;
        { int ij1 = 0;
        if( !j1valid[ij1] )
            continue;
        j1 = j1array[0]; cj1 = cj1array[0]; sj1 = sj1array[0];
        
        vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
        solution.basesol.resize(4);
        solution.basesol[0].foffset = j0;
        solution.basesol[1].foffset = j1;
        solution.basesol[2].foffset = j2;
        solution.basesol[3].foffset = j3;
        solution.vfree.resize(0);
        }
        }
        }
        }
        }
        }
        } else {
        evalcond=((((-1.00000000000000)*(3.14159265358979)))+(j3));
        if( IKabs(evalcond) < 0.00001 ) {
        {
        IKReal j0array[2], cj0array[2], sj0array[2];
        bool j0valid[2]={false};
        IKReal x62=((-1.00000000000000)*(py));
        IKReal x63=((-1.00000000000000)*(px));
        IKReal x64=IKatan2(x62, x63);
        j0array[0]=((-1.00000000000000)*(x64));
        sj0array[0]=IKsin(j0array[0]);
        cj0array[0]=IKcos(j0array[0]);
        j0array[1]=((3.14159265358979)+(((-1.00000000000000)*(x64))));
        sj0array[1]=IKsin(j0array[1]);
        cj0array[1]=IKcos(j0array[1]);
        if( j0array[0] > IKPI )
            j0array[0]-=IK2PI;
        else if( j0array[0] < -IKPI )
            j0array[0]+=IK2PI;
        j0valid[0] = true;
        if( j0array[1] > IKPI )
            j0array[1]-=IK2PI;
        else if( j0array[1] < -IKPI )
            j0array[1]+=IK2PI;
        j0valid[1] = true;
        if( j0valid[0] && j0valid[1] && IKabs(cj0array[0]-cj0array[1]) < 0.0001 && IKabs(sj0array[0]-sj0array[1]) < 0.0001 )
            j0valid[1]=false;
        for(int ij0 = 0; ij0 < 2; ++ij0) {
        if( !j0valid[ij0] )
            continue;
        j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
        
        {
        IKReal j2array[2], cj2array[2], sj2array[2];
        bool j2valid[2]={false};
        IKReal x65=((2.95366029808065)*(pz));
        IKReal x66=((5.95069079799578)*(cj0)*(px));
        IKReal x67=((1.13951554775122)+(x65)+(x66));
        IKReal x68=((5.95069079799578)*(py)*(sj0));
        IKReal x69=(px)*(px);
        IKReal x70=((37.3881050390191)*(x69));
        IKReal x71=(py)*(py);
        IKReal x72=((37.3881050390191)*(x71));
        IKReal x73=(pz)*(pz);
        IKReal x74=((37.3881050390191)*(x73));
        IKReal x75=((x74)+(x72)+(x70)+(x68));
        IKReal x76=((((-1.00000000000000)*(x75)))+(x67));
        if( (x76) < -1.0001 || (x76) > 1.0001 )
            continue;
        IKReal x77=IKasin(x76);
        j2array[0]=((-1.88825506204718)+(((-1.00000000000000)*(x77))));
        sj2array[0]=IKsin(j2array[0]);
        cj2array[0]=IKcos(j2array[0]);
        j2array[1]=((1.25333759154261)+(x77));
        sj2array[1]=IKsin(j2array[1]);
        cj2array[1]=IKcos(j2array[1]);
        if( j2array[0] > IKPI )
            j2array[0]-=IK2PI;
        else if( j2array[0] < -IKPI )
            j2array[0]+=IK2PI;
        j2valid[0] = true;
        if( j2array[1] > IKPI )
            j2array[1]-=IK2PI;
        else if( j2array[1] < -IKPI )
            j2array[1]+=IK2PI;
        j2valid[1] = true;
        if( j2valid[0] && j2valid[1] && IKabs(cj2array[0]-cj2array[1]) < 0.0001 && IKabs(sj2array[0]-sj2array[1]) < 0.0001 )
            j2valid[1]=false;
        for(int ij2 = 0; ij2 < 2; ++ij2) {
        if( !j2valid[ij2] )
            continue;
        j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
        
        {
        IKReal j1array[1], cj1array[1], sj1array[1];
        bool j1valid[1]={false};
        IKReal x78=((0.159159999999247)*(py)*(sj0));
        IKReal x79=x71;
        IKReal x80=(sj0)*(sj0);
        IKReal x81=((x79)*(x80));
        IKReal x82=x73;
        IKReal x83=(cj0)*(cj0);
        IKReal x84=x69;
        IKReal x85=((x83)*(x84));
        IKReal x86=((0.00789322639991497)+(x78)+(x82)+(x81)+(x85));
        IKReal x87=((12.5659713495988)*(cj0)*(px)*(x78));
        IKReal x88=((0.0789999999997235)*(pz));
        IKReal x89=((0.159159999999247)*(cj0)*(px));
        IKReal x90=((x88)+(x89)+(x87));
        IKReal x91=((x86)+(((-1.00000000000000)*(x90))));
        IKReal x92=((IKabs(x91) != 0)?((IKReal)1/(x91)):(IKReal)1.0e30);
        j1array[0]=IKatan2(((((0.144508670520736)*(cj2)*(x78)*(x92)))+(((0.00647909999992180)*(sj2)*(x92)))+(((0.439808997234650)*(sj2)*(x78)*(x92)))+(((-0.000934659999998644)*(cj2)*(x92)))+(((0.886075949361839)*(cj2)*(x88)*(x92)))+(((-0.439808997234650)*(sj2)*(x89)*(x92)))+(((-0.00716925000000401)*(x92)))+(((2.29746835443075)*(x88)*(x92)))+(((-0.144508670520736)*(cj2)*(x89)*(x92)))+(((-0.291139240503981)*(sj2)*(x88)*(x92)))), ((((-1.14036189997569)*(x78)*(x92)))+(((-0.0144437699999571)*(x92)))+(((-0.439808997234650)*(cj2)*(x78)*(x92)))+(((0.144508670520736)*(sj2)*(x78)*(x92)))+(((-0.144508670520736)*(sj2)*(x89)*(x92)))+(((-0.000934659999998644)*(sj2)*(x92)))+(((0.886075949361839)*(sj2)*(x88)*(x92)))+(((-0.00647909999992180)*(cj2)*(x92)))+(((0.439808997234650)*(cj2)*(x89)*(x92)))+(((0.291139240503981)*(cj2)*(x88)*(x92)))+(((1.14036189997569)*(x89)*(x92)))));
        sj1array[0]=IKsin(j1array[0]);
        cj1array[0]=IKcos(j1array[0]);
        if( j1array[0] > IKPI )
            j1array[0]-=IK2PI;
        else if( j1array[0] < -IKPI )
            j1array[0]+=IK2PI;
        j1valid[0] = true;
        { int ij1 = 0;
        if( !j1valid[ij1] )
            continue;
        j1 = j1array[0]; cj1 = cj1array[0]; sj1 = sj1array[0];
        
        vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
        solution.basesol.resize(4);
        solution.basesol[0].foffset = j0;
        solution.basesol[1].foffset = j1;
        solution.basesol[2].foffset = j2;
        solution.basesol[3].foffset = j3;
        solution.vfree.resize(0);
        }
        }
        }
        }
        }
        }
        } else {
        evalcond=((((0.500000000000000)*(3.14159265358979)))+(j3));
        if( IKabs(evalcond) < 0.00001 ) {
        {
        IKReal j0array[2], cj0array[2], sj0array[2];
        bool j0valid[2]={false};
        IKReal x93=((-1.00000000000000)*(py));
        IKReal x94=((-1.00000000000000)*(px));
        IKReal x95=IKatan2(x93, x94);
        j0array[0]=((-1.00000000000000)*(x95));
        sj0array[0]=IKsin(j0array[0]);
        cj0array[0]=IKcos(j0array[0]);
        j0array[1]=((3.14159265358979)+(((-1.00000000000000)*(x95))));
        sj0array[1]=IKsin(j0array[1]);
        cj0array[1]=IKcos(j0array[1]);
        if( j0array[0] > IKPI )
            j0array[0]-=IK2PI;
        else if( j0array[0] < -IKPI )
            j0array[0]+=IK2PI;
        j0valid[0] = true;
        if( j0array[1] > IKPI )
            j0array[1]-=IK2PI;
        else if( j0array[1] < -IKPI )
            j0array[1]+=IK2PI;
        j0valid[1] = true;
        if( j0valid[0] && j0valid[1] && IKabs(cj0array[0]-cj0array[1]) < 0.0001 && IKabs(sj0array[0]-sj0array[1]) < 0.0001 )
            j0valid[1]=false;
        for(int ij0 = 0; ij0 < 2; ++ij0) {
        if( !j0valid[ij0] )
            continue;
        j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
        
        {
        IKReal j2array[2], cj2array[2], sj2array[2];
        bool j2valid[2]={false};
        IKReal x96=((2.95366029808065)*(pz));
        IKReal x97=((5.95069079799578)*(cj0)*(px));
        IKReal x98=((1.13951554775122)+(x97)+(x96));
        IKReal x99=((5.95069079799578)*(py)*(sj0));
        IKReal x100=(px)*(px);
        IKReal x101=((37.3881050390191)*(x100));
        IKReal x102=(py)*(py);
        IKReal x103=((37.3881050390191)*(x102));
        IKReal x104=(pz)*(pz);
        IKReal x105=((37.3881050390191)*(x104));
        IKReal x106=((x105)+(x101)+(x103)+(x99));
        IKReal x107=((((-1.00000000000000)*(x106)))+(x98));
        if( (x107) < -1.0001 || (x107) > 1.0001 )
            continue;
        IKReal x108=IKasin(x107);
        j2array[0]=((-1.88825506204718)+(((-1.00000000000000)*(x108))));
        sj2array[0]=IKsin(j2array[0]);
        cj2array[0]=IKcos(j2array[0]);
        j2array[1]=((1.25333759154261)+(x108));
        sj2array[1]=IKsin(j2array[1]);
        cj2array[1]=IKcos(j2array[1]);
        if( j2array[0] > IKPI )
            j2array[0]-=IK2PI;
        else if( j2array[0] < -IKPI )
            j2array[0]+=IK2PI;
        j2valid[0] = true;
        if( j2array[1] > IKPI )
            j2array[1]-=IK2PI;
        else if( j2array[1] < -IKPI )
            j2array[1]+=IK2PI;
        j2valid[1] = true;
        if( j2valid[0] && j2valid[1] && IKabs(cj2array[0]-cj2array[1]) < 0.0001 && IKabs(sj2array[0]-sj2array[1]) < 0.0001 )
            j2valid[1]=false;
        for(int ij2 = 0; ij2 < 2; ++ij2) {
        if( !j2valid[ij2] )
            continue;
        j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
        
        {
        IKReal j1array[1], cj1array[1], sj1array[1];
        bool j1valid[1]={false};
        IKReal x109=((0.159159999999247)*(py)*(sj0));
        IKReal x110=x102;
        IKReal x111=(sj0)*(sj0);
        IKReal x112=((x110)*(x111));
        IKReal x113=x104;
        IKReal x114=(cj0)*(cj0);
        IKReal x115=x100;
        IKReal x116=((x114)*(x115));
        IKReal x117=((0.00789322639991497)+(x113)+(x112)+(x116)+(x109));
        IKReal x118=((12.5659713495988)*(cj0)*(px)*(x109));
        IKReal x119=((0.0789999999997235)*(pz));
        IKReal x120=((0.159159999999247)*(cj0)*(px));
        IKReal x121=((x120)+(x119)+(x118));
        IKReal x122=((((-1.00000000000000)*(x121)))+(x117));
        IKReal x123=((IKabs(x122) != 0)?((IKReal)1/(x122)):(IKReal)1.0e30);
        j1array[0]=IKatan2(((((0.439808997234650)*(sj2)*(x109)*(x123)))+(((2.29746835443075)*(x119)*(x123)))+(((0.886075949361839)*(cj2)*(x119)*(x123)))+(((0.144508670520736)*(cj2)*(x109)*(x123)))+(((-0.00716925000000401)*(x123)))+(((-0.291139240503981)*(sj2)*(x119)*(x123)))+(((0.00647909999992180)*(sj2)*(x123)))+(((-0.144508670520736)*(cj2)*(x120)*(x123)))+(((-0.439808997234650)*(sj2)*(x120)*(x123)))+(((-0.000934659999998644)*(cj2)*(x123)))), ((((-0.0144437699999571)*(x123)))+(((0.439808997234650)*(cj2)*(x120)*(x123)))+(((-0.000934659999998644)*(sj2)*(x123)))+(((1.14036189997569)*(x120)*(x123)))+(((0.886075949361839)*(sj2)*(x119)*(x123)))+(((-0.439808997234650)*(cj2)*(x109)*(x123)))+(((0.144508670520736)*(sj2)*(x109)*(x123)))+(((0.291139240503981)*(cj2)*(x119)*(x123)))+(((-1.14036189997569)*(x109)*(x123)))+(((-0.144508670520736)*(sj2)*(x120)*(x123)))+(((-0.00647909999992180)*(cj2)*(x123)))));
        sj1array[0]=IKsin(j1array[0]);
        cj1array[0]=IKcos(j1array[0]);
        if( j1array[0] > IKPI )
            j1array[0]-=IK2PI;
        else if( j1array[0] < -IKPI )
            j1array[0]+=IK2PI;
        j1valid[0] = true;
        { int ij1 = 0;
        if( !j1valid[ij1] )
            continue;
        j1 = j1array[0]; cj1 = cj1array[0]; sj1 = sj1array[0];
        
        vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
        solution.basesol.resize(4);
        solution.basesol[0].foffset = j0;
        solution.basesol[1].foffset = j1;
        solution.basesol[2].foffset = j2;
        solution.basesol[3].foffset = j3;
        solution.vfree.resize(0);
        }
        }
        }
        }
        }
        }
        } else {
        if( 1 ) {
        {
        IKReal j0array[2], cj0array[2], sj0array[2];
        bool j0valid[2]={false};
        IKReal x124=((-1.00000000000000)*(py));
        IKReal x125=((-1.00000000000000)*(px));
        IKReal x126=IKatan2(x124, x125);
        j0array[0]=((-1.00000000000000)*(x126));
        sj0array[0]=IKsin(j0array[0]);
        cj0array[0]=IKcos(j0array[0]);
        j0array[1]=((3.14159265358979)+(((-1.00000000000000)*(x126))));
        sj0array[1]=IKsin(j0array[1]);
        cj0array[1]=IKcos(j0array[1]);
        if( j0array[0] > IKPI )
            j0array[0]-=IK2PI;
        else if( j0array[0] < -IKPI )
            j0array[0]+=IK2PI;
        j0valid[0] = true;
        if( j0array[1] > IKPI )
            j0array[1]-=IK2PI;
        else if( j0array[1] < -IKPI )
            j0array[1]+=IK2PI;
        j0valid[1] = true;
        if( j0valid[0] && j0valid[1] && IKabs(cj0array[0]-cj0array[1]) < 0.0001 && IKabs(sj0array[0]-sj0array[1]) < 0.0001 )
            j0valid[1]=false;
        for(int ij0 = 0; ij0 < 2; ++ij0) {
        if( !j0valid[ij0] )
            continue;
        j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
        
        {
        IKReal j2array[2], cj2array[2], sj2array[2];
        bool j2valid[2]={false};
        IKReal x127=((2.95366029808065)*(pz));
        IKReal x128=((5.95069079799578)*(cj0)*(px));
        IKReal x129=((1.13951554775122)+(x127)+(x128));
        IKReal x130=((5.95069079799578)*(py)*(sj0));
        IKReal x131=(px)*(px);
        IKReal x132=((37.3881050390191)*(x131));
        IKReal x133=(py)*(py);
        IKReal x134=((37.3881050390191)*(x133));
        IKReal x135=(pz)*(pz);
        IKReal x136=((37.3881050390191)*(x135));
        IKReal x137=((x134)+(x136)+(x130)+(x132));
        IKReal x138=((x129)+(((-1.00000000000000)*(x137))));
        if( (x138) < -1.0001 || (x138) > 1.0001 )
            continue;
        IKReal x139=IKasin(x138);
        j2array[0]=((-1.88825506204718)+(((-1.00000000000000)*(x139))));
        sj2array[0]=IKsin(j2array[0]);
        cj2array[0]=IKcos(j2array[0]);
        j2array[1]=((1.25333759154261)+(x139));
        sj2array[1]=IKsin(j2array[1]);
        cj2array[1]=IKcos(j2array[1]);
        if( j2array[0] > IKPI )
            j2array[0]-=IK2PI;
        else if( j2array[0] < -IKPI )
            j2array[0]+=IK2PI;
        j2valid[0] = true;
        if( j2array[1] > IKPI )
            j2array[1]-=IK2PI;
        else if( j2array[1] < -IKPI )
            j2array[1]+=IK2PI;
        j2valid[1] = true;
        if( j2valid[0] && j2valid[1] && IKabs(cj2array[0]-cj2array[1]) < 0.0001 && IKabs(sj2array[0]-sj2array[1]) < 0.0001 )
            j2valid[1]=false;
        for(int ij2 = 0; ij2 < 2; ++ij2) {
        if( !j2valid[ij2] )
            continue;
        j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
        
        {
        IKReal j1array[1], cj1array[1], sj1array[1];
        bool j1valid[1]={false};
        IKReal x140=((0.159159999999247)*(py)*(sj0));
        IKReal x141=x133;
        IKReal x142=(sj0)*(sj0);
        IKReal x143=((x141)*(x142));
        IKReal x144=x135;
        IKReal x145=(cj0)*(cj0);
        IKReal x146=x131;
        IKReal x147=((x145)*(x146));
        IKReal x148=((0.00789322639991497)+(x140)+(x143)+(x144)+(x147));
        IKReal x149=((12.5659713495988)*(cj0)*(px)*(x140));
        IKReal x150=((0.0789999999997235)*(pz));
        IKReal x151=((0.159159999999247)*(cj0)*(px));
        IKReal x152=((x151)+(x150)+(x149));
        IKReal x153=((((-1.00000000000000)*(x152)))+(x148));
        IKReal x154=((IKabs(x153) != 0)?((IKReal)1/(x153)):(IKReal)1.0e30);
        j1array[0]=IKatan2(((((-0.000934659999998644)*(cj2)*(x154)))+(((0.886075949361839)*(cj2)*(x150)*(x154)))+(((-0.144508670520736)*(cj2)*(x151)*(x154)))+(((-0.439808997234650)*(sj2)*(x151)*(x154)))+(((0.144508670520736)*(cj2)*(x140)*(x154)))+(((2.29746835443075)*(x150)*(x154)))+(((-0.291139240503981)*(sj2)*(x150)*(x154)))+(((-0.00716925000000401)*(x154)))+(((0.439808997234650)*(sj2)*(x140)*(x154)))+(((0.00647909999992180)*(sj2)*(x154)))), ((((0.439808997234650)*(cj2)*(x151)*(x154)))+(((0.886075949361839)*(sj2)*(x150)*(x154)))+(((-0.439808997234650)*(cj2)*(x140)*(x154)))+(((-1.14036189997569)*(x140)*(x154)))+(((-0.00647909999992180)*(cj2)*(x154)))+(((0.144508670520736)*(sj2)*(x140)*(x154)))+(((-0.144508670520736)*(sj2)*(x151)*(x154)))+(((0.291139240503981)*(cj2)*(x150)*(x154)))+(((-0.000934659999998644)*(sj2)*(x154)))+(((1.14036189997569)*(x151)*(x154)))+(((-0.0144437699999571)*(x154)))));
        sj1array[0]=IKsin(j1array[0]);
        cj1array[0]=IKcos(j1array[0]);
        if( j1array[0] > IKPI )
            j1array[0]-=IK2PI;
        else if( j1array[0] < -IKPI )
            j1array[0]+=IK2PI;
        j1valid[0] = true;
        { int ij1 = 0;
        if( !j1valid[ij1] )
            continue;
        j1 = j1array[0]; cj1 = cj1array[0]; sj1 = sj1array[0];
        
        vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
        solution.basesol.resize(4);
        solution.basesol[0].foffset = j0;
        solution.basesol[1].foffset = j1;
        solution.basesol[2].foffset = j2;
        solution.basesol[3].foffset = j3;
        solution.vfree.resize(0);
        }
        }
        }
        }
        }
        }
        } else {
    }
    }
    }
    }
    }
    }
    }
return vsolutions.size()>0;
}

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    if( argc != 12+getNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",getNumFreeParameters());
        return 1;
    }

    std::vector<IKSolution> vsolutions;
    std::vector<IKReal> vfree(getNumFreeParameters());
    IKReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)vsolutions.size());
    std::vector<IKReal> sol(getNumJoints());
    for(size_t i = 0; i < vsolutions.size(); ++i) {
        printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
        std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
        vsolutions[i].GetSolution(&sol[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( size_t j = 0; j < sol.size(); ++j)
            printf("%f, ", (float)sol[j]);
        printf("\n");
    }
    return 0;
}

#endif
